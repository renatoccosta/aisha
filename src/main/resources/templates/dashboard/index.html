<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="#{dashboard.title}"></title>
    <link rel="stylesheet" th:href="@{/css/app.css}">
    <link rel="icon" type="image/svg+xml" th:href="@{/img/logo-option-1.svg}">
    <script th:src="@{/webjars/chart.js/4.5.1/dist/chart.umd.min.js}"></script>
</head>
<body>
<header th:replace="~{fragments/header :: topbar(subtitle=#{dashboard.header.subtitle})}"></header>

<main class="wrap dashboard-main">
    <section class="dashboard-card-grid">
        <article class="card summary-card summary-card-balance loading" id="summary-current-balance">
            <div class="summary-card-head">
                <span class="summary-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" focusable="false">
                        <path d="M3 7.5A2.5 2.5 0 0 1 5.5 5h13A2.5 2.5 0 0 1 21 7.5v9a2.5 2.5 0 0 1-2.5 2.5h-13A2.5 2.5 0 0 1 3 16.5v-9Zm2 0v1.25h14V7.5a.5.5 0 0 0-.5-.5h-13a.5.5 0 0 0-.5.5Zm0 3.25v5.75c0 .27.22.5.5.5h13a.5.5 0 0 0 .5-.5v-5.75H5Zm8 3a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"/>
                    </svg>
                </span>
                <h2 th:text="#{dashboard.card.currentBalance}"></h2>
            </div>
            <p class="summary-value skeleton-line" data-role="value">R$ 0,00</p>
            <p class="summary-variation skeleton-line" data-role="variation" th:text="#{dashboard.loading}"></p>
        </article>

        <article class="card summary-card summary-card-expense loading" id="summary-total-expenses">
            <div class="summary-card-head">
                <span class="summary-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" focusable="false">
                        <path d="M4 4h16v2H4V4Zm0 7h11v2H4v-2Zm0 7h8v2H4v-2Zm14-8 4 4-4 4-1.4-1.4 1.6-1.6H13v-2h5.2l-1.6-1.6L18 10Z"/>
                    </svg>
                </span>
                <h2 th:text="#{dashboard.card.totalExpenses}"></h2>
            </div>
            <p class="summary-value skeleton-line" data-role="value">R$ 0,00</p>
            <p class="summary-variation skeleton-line" data-role="variation" th:text="#{dashboard.loading}"></p>
        </article>

        <article class="card summary-card summary-card-revenue loading" id="summary-total-revenues">
            <div class="summary-card-head">
                <span class="summary-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" focusable="false">
                        <path d="M4 4h16v2H4V4Zm0 7h8v2H4v-2Zm0 7h11v2H4v-2Zm10-8h5.2l-1.6-1.6L19 7l4 4-4 4-1.4-1.4 1.6-1.6H14v-2Z"/>
                    </svg>
                </span>
                <h2 th:text="#{dashboard.card.totalRevenues}"></h2>
            </div>
            <p class="summary-value skeleton-line" data-role="value">R$ 0,00</p>
            <p class="summary-variation skeleton-line" data-role="variation" th:text="#{dashboard.loading}"></p>
        </article>
    </section>

    <section class="card chart-card loading" id="balance-chart-card">
        <div class="chart-card-head">
            <div>
                <h2 th:text="#{dashboard.chart.title}"></h2>
                <p th:text="#{dashboard.chart.subtitle}"></p>
            </div>
            <div class="chart-mode-selector" role="group" th:attr="aria-label=#{dashboard.chart.mode.aria}">
                <button class="btn btn-secondary btn-active" type="button" data-mode="accumulated" th:text="#{dashboard.chart.mode.accumulated}"></button>
                <button class="btn btn-secondary" type="button" data-mode="period" th:text="#{dashboard.chart.mode.period}"></button>
            </div>
        </div>
        <p class="chart-meta" id="balance-chart-meta" th:text="#{dashboard.loading}"></p>
        <div class="chart-wrap">
            <canvas id="balance-evolution-chart" th:attr="aria-label=#{dashboard.chart.title}"></canvas>
        </div>
    </section>

    <section class="dashboard-chart-grid">
        <article class="card chart-card loading" id="revenues-expenses-chart-card">
            <div class="chart-card-head">
                <div>
                    <h2 th:text="#{dashboard.revenueExpenseChart.title}"></h2>
                    <p th:text="#{dashboard.revenueExpenseChart.subtitle}"></p>
                </div>
            </div>
            <p class="chart-meta" id="revenues-expenses-chart-meta" th:text="#{dashboard.loading}"></p>
            <div class="chart-wrap">
                <canvas id="revenues-expenses-chart" th:attr="aria-label=#{dashboard.revenueExpenseChart.title}"></canvas>
            </div>
        </article>

        <article class="card chart-card loading" id="expense-category-chart-card">
            <div class="chart-card-head">
                <div>
                    <h2 th:text="#{dashboard.expenseCategoryChart.title}"></h2>
                    <p th:text="#{dashboard.expenseCategoryChart.subtitle}"></p>
                </div>
                <button class="btn btn-secondary" id="expense-category-drill-up" type="button" disabled th:text="#{dashboard.expenseCategoryChart.drillUp}"></button>
            </div>
            <p class="chart-meta" id="expense-category-chart-meta" th:text="#{dashboard.loading}"></p>
            <div class="chart-wrap">
                <canvas id="expense-category-chart" th:attr="aria-label=#{dashboard.expenseCategoryChart.title}"></canvas>
            </div>
        </article>
    </section>

    <section class="card chart-card loading" id="category-totals-chart-card">
        <div class="chart-card-head">
            <div>
                <h2 th:text="#{dashboard.categoryTotalsChart.title}"></h2>
                <p th:text="#{dashboard.categoryTotalsChart.subtitle}"></p>
            </div>
            <button class="btn btn-secondary" id="category-totals-drill-up" type="button" disabled th:text="#{dashboard.categoryTotalsChart.drillUp}"></button>
        </div>
        <p class="chart-meta" id="category-totals-chart-meta" th:text="#{dashboard.loading}"></p>
        <div class="chart-wrap">
            <canvas id="category-totals-chart" th:attr="aria-label=#{dashboard.categoryTotalsChart.title}"></canvas>
        </div>
    </section>
</main>

<script th:inline="javascript">
    const i18n = {
        loading: /*[[#{dashboard.loading}]]*/ "Carregando...",
        unavailablePrevious: /*[[#{dashboard.variation.previousUnavailable}]]*/ "Sem base de comparação no período anterior",
        variationUp: /*[[#{dashboard.variation.up}]]*/ "acima do período anterior",
        variationDown: /*[[#{dashboard.variation.down}]]*/ "abaixo do período anterior",
        variationStable: /*[[#{dashboard.variation.stable}]]*/ "igual ao período anterior",
        chartMeta: /*[[#{dashboard.chart.meta}]]*/ "Período: {0} até {1} ({2})",
        chartGranularityDay: /*[[#{dashboard.chart.granularity.day}]]*/ "diário",
        chartGranularityMonth: /*[[#{dashboard.chart.granularity.month}]]*/ "mensal",
        chartSeriesAccumulated: /*[[#{dashboard.chart.series.accumulated}]]*/ "Saldo acumulado",
        chartSeriesPeriod: /*[[#{dashboard.chart.series.period}]]*/ "Movimentação no período",
        chartLoadError: /*[[#{dashboard.chart.error}]]*/ "Não foi possível carregar o gráfico.",
        summaryLoadError: /*[[#{dashboard.summary.error}]]*/ "Não foi possível carregar este indicador.",
        revenueExpenseChartSeriesRevenue: /*[[#{dashboard.revenueExpenseChart.series.revenues}]]*/ "Receitas",
        revenueExpenseChartSeriesExpense: /*[[#{dashboard.revenueExpenseChart.series.expenses}]]*/ "Despesas",
        revenueExpenseChartLoadError: /*[[#{dashboard.revenueExpenseChart.error}]]*/ "Não foi possível carregar o gráfico de receitas vs despesas.",
        expenseCategoryChartLoadError: /*[[#{dashboard.expenseCategoryChart.error}]]*/ "Não foi possível carregar o gráfico de gastos por categoria.",
        expenseCategoryChartEmpty: /*[[#{dashboard.expenseCategoryChart.empty}]]*/ "Sem despesas no período",
        expenseCategoryChartLevelRoot: /*[[#{dashboard.expenseCategoryChart.level.root}]]*/ "Nível: categorias raiz",
        expenseCategoryChartLevelChild: /*[[#{dashboard.expenseCategoryChart.level.child}]]*/ "Nível: subcategorias de {0}",
        categoryTotalsChartLoadError: /*[[#{dashboard.categoryTotalsChart.error}]]*/ "Não foi possível carregar o gráfico de totais por categoria.",
        categoryTotalsChartEmpty: /*[[#{dashboard.categoryTotalsChart.empty}]]*/ "Sem dados no período",
        categoryTotalsChartLevelRoot: /*[[#{dashboard.categoryTotalsChart.level.root}]]*/ "Nível: categorias raiz",
        categoryTotalsChartLevelChild: /*[[#{dashboard.categoryTotalsChart.level.child}]]*/ "Nível: subcategorias de {0}",
        chartMetaRange: /*[[#{dashboard.chart.metaRange}]]*/ "Período: {0} até {1}"
    };

    const BRL_FORMATTER = new Intl.NumberFormat("pt-BR", { style: "currency", currency: "BRL" });
    const PERCENT_FORMATTER = new Intl.NumberFormat("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const DATE_FORMATTER = new Intl.DateTimeFormat("pt-BR");
    const MONTH_FORMATTER = new Intl.DateTimeFormat("pt-BR", { month: "short", year: "numeric" });
    let balanceChart = null;
    let chartPayload = null;
    let revenueExpenseChart = null;
    let revenueExpensePayload = null;
    let expenseCategoryChart = null;
    let expenseCategoryPayload = null;
    let expenseCategoryDrillUpParentId = null;
    let categoryTotalsChart = null;
    let categoryTotalsPayload = null;
    let categoryTotalsDrillUpParentId = null;

    function formatCurrency(value) {
        return BRL_FORMATTER.format(Number(value ?? 0));
    }

    function formatDate(isoDate) {
        return DATE_FORMATTER.format(new Date(`${isoDate}T00:00:00`));
    }

    function formatMonth(isoDate) {
        return MONTH_FORMATTER.format(new Date(`${isoDate}T00:00:00`));
    }

    function replaceMeta(text, values) {
        return text.replace("{0}", values[0]).replace("{1}", values[1]).replace("{2}", values[2]);
    }

    function replaceMetaRange(text, values) {
        return text.replace("{0}", values[0]).replace("{1}", values[1]);
    }

    function renderMetric(cardId, metric) {
        const card = document.getElementById(cardId);
        if (!card) {
            return;
        }

        card.classList.remove("loading");
        const valueElement = card.querySelector('[data-role="value"]');
        const variationElement = card.querySelector('[data-role="variation"]');

        valueElement.textContent = formatCurrency(metric.currentValue);
        valueElement.classList.remove("skeleton-line");

        variationElement.classList.remove("skeleton-line", "variation-up", "variation-down", "variation-stable");
        if (metric.variationPercent === null) {
            variationElement.textContent = i18n.unavailablePrevious;
            return;
        }

        const percent = Number(metric.variationPercent);
        const absPercent = PERCENT_FORMATTER.format(Math.abs(percent));
        if (percent > 0) {
            variationElement.textContent = `+${absPercent}% ${i18n.variationUp}`;
            variationElement.classList.add("variation-up");
            return;
        }
        if (percent < 0) {
            variationElement.textContent = `-${absPercent}% ${i18n.variationDown}`;
            variationElement.classList.add("variation-down");
            return;
        }

        variationElement.textContent = `0,00% ${i18n.variationStable}`;
        variationElement.classList.add("variation-stable");
    }

    async function loadSummary() {
        const cards = [
            document.getElementById("summary-current-balance"),
            document.getElementById("summary-total-expenses"),
            document.getElementById("summary-total-revenues")
        ];

        try {
            const response = await fetch("/api/dashboard/summary", { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("summary-failed");
            }
            const data = await response.json();
            renderMetric("summary-current-balance", data.currentBalance);
            renderMetric("summary-total-expenses", data.totalExpenses);
            renderMetric("summary-total-revenues", data.totalRevenues);
        } catch (error) {
            cards.forEach((card) => {
                if (!card) {
                    return;
                }
                card.classList.remove("loading");
                const valueElement = card.querySelector('[data-role="value"]');
                const variationElement = card.querySelector('[data-role="variation"]');
                valueElement.textContent = "-";
                valueElement.classList.remove("skeleton-line");
                variationElement.textContent = i18n.summaryLoadError;
                variationElement.classList.remove("skeleton-line");
            });
        }
    }

    function renderChart(mode) {
        if (!chartPayload) {
            return;
        }

        const labels = chartPayload.points.map((point) => (
            chartPayload.granularity === "MONTH" ? formatMonth(point.date) : formatDate(point.date)
        ));
        const dataset = chartPayload.points.map((point) => (
            mode === "period" ? Number(point.periodAmount) : Number(point.accumulatedBalance)
        ));
        const seriesLabel = mode === "period" ? i18n.chartSeriesPeriod : i18n.chartSeriesAccumulated;

        const canvas = document.getElementById("balance-evolution-chart");
        if (!canvas) {
            return;
        }

        if (balanceChart) {
            balanceChart.destroy();
        }

        balanceChart = new Chart(canvas, {
            type: "line",
            data: {
                labels,
                datasets: [{
                    label: seriesLabel,
                    data: dataset,
                    borderColor: "#0b7fab",
                    backgroundColor: "rgba(11, 127, 171, 0.14)",
                    fill: true,
                    tension: 0.25,
                    pointRadius: 2.5,
                    pointHoverRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        ticks: {
                            callback: (value) => formatCurrency(value)
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.dataset.label}: ${formatCurrency(context.raw)}`
                        }
                    }
                }
            }
        });
    }

    async function loadBalanceEvolution() {
        const card = document.getElementById("balance-chart-card");
        const meta = document.getElementById("balance-chart-meta");
        if (!card || !meta) {
            return;
        }

        try {
            const response = await fetch("/api/dashboard/balance-evolution", { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("chart-failed");
            }
            chartPayload = await response.json();
            card.classList.remove("loading");

            const granularityLabel = chartPayload.granularity === "MONTH"
                ? i18n.chartGranularityMonth
                : i18n.chartGranularityDay;

            meta.textContent = replaceMeta(i18n.chartMeta, [
                formatDate(chartPayload.startDate),
                formatDate(chartPayload.endDate),
                granularityLabel
            ]);

            renderChart("accumulated");
        } catch (error) {
            card.classList.remove("loading");
            meta.textContent = i18n.chartLoadError;
        }
    }

    function renderRevenueExpenseChart() {
        if (!revenueExpensePayload) {
            return;
        }

        const labels = revenueExpensePayload.points.map((point) => (
            revenueExpensePayload.granularity === "MONTH" ? formatMonth(point.date) : formatDate(point.date)
        ));

        const revenueData = revenueExpensePayload.points.map((point) => Number(point.revenues));
        const expenseData = revenueExpensePayload.points.map((point) => Number(point.expenses));

        const canvas = document.getElementById("revenues-expenses-chart");
        if (!canvas) {
            return;
        }

        if (revenueExpenseChart) {
            revenueExpenseChart.destroy();
        }

        revenueExpenseChart = new Chart(canvas, {
            type: "bar",
            data: {
                labels,
                datasets: [
                    {
                        label: i18n.revenueExpenseChartSeriesRevenue,
                        data: revenueData,
                        backgroundColor: "rgba(36, 138, 84, 0.85)",
                        borderColor: "#1b7e4b",
                        borderWidth: 1.2,
                        stack: "cashflow"
                    },
                    {
                        label: i18n.revenueExpenseChartSeriesExpense,
                        data: expenseData,
                        backgroundColor: "rgba(189, 64, 56, 0.85)",
                        borderColor: "#9e2f2b",
                        borderWidth: 1.2,
                        stack: "cashflow"
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true
                    },
                    y: {
                        stacked: true,
                        ticks: {
                            callback: (value) => formatCurrency(value)
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.dataset.label}: ${formatCurrency(context.raw)}`
                        }
                    }
                }
            }
        });
    }

    async function loadRevenueExpenseEvolution() {
        const card = document.getElementById("revenues-expenses-chart-card");
        const meta = document.getElementById("revenues-expenses-chart-meta");
        if (!card || !meta) {
            return;
        }

        try {
            const response = await fetch("/api/dashboard/revenues-vs-expenses", { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("revenue-expense-chart-failed");
            }
            revenueExpensePayload = await response.json();
            card.classList.remove("loading");

            const granularityLabel = revenueExpensePayload.granularity === "MONTH"
                ? i18n.chartGranularityMonth
                : i18n.chartGranularityDay;

            meta.textContent = replaceMeta(i18n.chartMeta, [
                formatDate(revenueExpensePayload.startDate),
                formatDate(revenueExpensePayload.endDate),
                granularityLabel
            ]);

            renderRevenueExpenseChart();
        } catch (error) {
            card.classList.remove("loading");
            meta.textContent = i18n.revenueExpenseChartLoadError;
        }
    }

    function renderExpenseCategoryChart() {
        if (!expenseCategoryPayload) {
            return;
        }

        const canvas = document.getElementById("expense-category-chart");
        if (!canvas) {
            return;
        }

        const hasItems = expenseCategoryPayload.items.length > 0;
        const labels = hasItems
            ? expenseCategoryPayload.items.map((item) => item.categoryName)
            : [i18n.expenseCategoryChartEmpty];
        const data = hasItems
            ? expenseCategoryPayload.items.map((item) => Number(item.amount))
            : [1];
        const colors = hasItems
            ? ["#0b7fab", "#1f7346", "#a75f00", "#7a4c8e", "#ba3f32", "#64748b"]
            : ["#d6dde5"];

        if (expenseCategoryChart) {
            expenseCategoryChart.destroy();
        }

        expenseCategoryChart = new Chart(canvas, {
            type: "doughnut",
            data: {
                labels,
                datasets: [{
                    data,
                    backgroundColor: colors,
                    borderColor: "#ffffff",
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: "bottom"
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                if (!hasItems) {
                                    return context.label;
                                }
                                return `${context.label}: ${formatCurrency(context.raw)}`;
                            }
                        }
                    }
                },
                onClick: (_, elements) => {
                    if (!hasItems || elements.length === 0) {
                        return;
                    }
                    const index = elements[0].index;
                    const selectedItem = expenseCategoryPayload.items[index];
                    if (!selectedItem || !selectedItem.hasChildren) {
                        return;
                    }
                    loadExpenseCategoryBreakdown(selectedItem.categoryId);
                }
            }
        });
    }

    async function loadExpenseCategoryBreakdown(parentCategoryId = null) {
        const card = document.getElementById("expense-category-chart-card");
        const meta = document.getElementById("expense-category-chart-meta");
        const drillUpButton = document.getElementById("expense-category-drill-up");
        if (!card || !meta) {
            return;
        }

        try {
            const url = new URL("/api/dashboard/expenses-by-category", window.location.origin);
            if (parentCategoryId !== null) {
                url.searchParams.set("parentCategoryId", String(parentCategoryId));
            }

            const response = await fetch(url.toString(), { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("expense-category-chart-failed");
            }
            expenseCategoryPayload = await response.json();
            card.classList.remove("loading");

            const periodLabel = replaceMetaRange(i18n.chartMetaRange, [
                formatDate(expenseCategoryPayload.startDate),
                formatDate(expenseCategoryPayload.endDate)
            ]);
            const levelLabel = expenseCategoryPayload.currentParentCategoryName
                ? i18n.expenseCategoryChartLevelChild.replace("{0}", expenseCategoryPayload.currentParentCategoryName)
                : i18n.expenseCategoryChartLevelRoot;
            meta.textContent = `${periodLabel} • ${levelLabel}`;

            expenseCategoryDrillUpParentId = expenseCategoryPayload.drillUpParentCategoryId;
            if (drillUpButton) {
                drillUpButton.disabled = expenseCategoryPayload.currentParentCategoryId === null;
            }

            renderExpenseCategoryChart();
        } catch (error) {
            card.classList.remove("loading");
            meta.textContent = i18n.expenseCategoryChartLoadError;
            if (drillUpButton) {
                drillUpButton.disabled = true;
            }
        }
    }

    function renderCategoryTotalsChart() {
        if (!categoryTotalsPayload) {
            return;
        }

        const canvas = document.getElementById("category-totals-chart");
        if (!canvas) {
            return;
        }

        const hasData = categoryTotalsPayload.buckets.length > 0 && categoryTotalsPayload.series.length > 0;
        const labels = hasData
            ? categoryTotalsPayload.buckets.map((bucket) => (
                categoryTotalsPayload.granularity === "MONTH" ? formatMonth(bucket) : formatDate(bucket)
            ))
            : [i18n.categoryTotalsChartEmpty];

        const palette = ["#0b7fab", "#1f7346", "#a75f00", "#7a4c8e", "#ba3f32", "#64748b", "#0f766e", "#9a3412"];
        const datasets = hasData
            ? categoryTotalsPayload.series.map((series, index) => ({
                label: series.categoryName,
                data: series.values.map((value) => Number(value)),
                backgroundColor: palette[index % palette.length],
                borderColor: "#ffffff",
                borderWidth: 1,
                stack: "categoryTotals"
            }))
            : [{
                label: i18n.categoryTotalsChartEmpty,
                data: [0],
                backgroundColor: "#d6dde5",
                stack: "categoryTotals"
            }];

        if (categoryTotalsChart) {
            categoryTotalsChart.destroy();
        }

        categoryTotalsChart = new Chart(canvas, {
            type: "bar",
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { stacked: true },
                    y: {
                        stacked: true,
                        ticks: {
                            callback: (value) => formatCurrency(value)
                        }
                    }
                },
                plugins: {
                    legend: { position: "bottom" },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.dataset.label}: ${formatCurrency(context.raw)}`
                        }
                    }
                },
                onClick: (_, elements) => {
                    if (!hasData || elements.length === 0) {
                        return;
                    }
                    const selectedSeries = categoryTotalsPayload.series[elements[0].datasetIndex];
                    if (!selectedSeries || !selectedSeries.hasChildren) {
                        return;
                    }
                    loadCategoryTotalsEvolution(selectedSeries.categoryId);
                }
            }
        });
    }

    async function loadCategoryTotalsEvolution(parentCategoryId = null) {
        const card = document.getElementById("category-totals-chart-card");
        const meta = document.getElementById("category-totals-chart-meta");
        const drillUpButton = document.getElementById("category-totals-drill-up");
        if (!card || !meta) {
            return;
        }

        try {
            const url = new URL("/api/dashboard/category-totals", window.location.origin);
            if (parentCategoryId !== null) {
                url.searchParams.set("parentCategoryId", String(parentCategoryId));
            }

            const response = await fetch(url.toString(), { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("category-totals-chart-failed");
            }
            categoryTotalsPayload = await response.json();
            card.classList.remove("loading");

            const periodLabel = replaceMetaRange(i18n.chartMetaRange, [
                formatDate(categoryTotalsPayload.startDate),
                formatDate(categoryTotalsPayload.endDate)
            ]);
            const levelLabel = categoryTotalsPayload.currentParentCategoryName
                ? i18n.categoryTotalsChartLevelChild.replace("{0}", categoryTotalsPayload.currentParentCategoryName)
                : i18n.categoryTotalsChartLevelRoot;
            const granularityLabel = categoryTotalsPayload.granularity === "MONTH"
                ? i18n.chartGranularityMonth
                : i18n.chartGranularityDay;
            meta.textContent = `${periodLabel} • ${levelLabel} • ${granularityLabel}`;

            categoryTotalsDrillUpParentId = categoryTotalsPayload.drillUpParentCategoryId;
            if (drillUpButton) {
                drillUpButton.disabled = categoryTotalsPayload.currentParentCategoryId === null;
            }

            renderCategoryTotalsChart();
        } catch (error) {
            card.classList.remove("loading");
            meta.textContent = i18n.categoryTotalsChartLoadError;
            if (drillUpButton) {
                drillUpButton.disabled = true;
            }
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        loadSummary();
        loadBalanceEvolution();
        loadRevenueExpenseEvolution();
        loadExpenseCategoryBreakdown();
        loadCategoryTotalsEvolution();

        const drillUpButton = document.getElementById("expense-category-drill-up");
        if (drillUpButton) {
            drillUpButton.addEventListener("click", () => {
                loadExpenseCategoryBreakdown(expenseCategoryDrillUpParentId);
            });
        }

        const categoryTotalsDrillUpButton = document.getElementById("category-totals-drill-up");
        if (categoryTotalsDrillUpButton) {
            categoryTotalsDrillUpButton.addEventListener("click", () => {
                loadCategoryTotalsEvolution(categoryTotalsDrillUpParentId);
            });
        }

        const selectorButtons = Array.from(document.querySelectorAll(".chart-mode-selector [data-mode]"));
        selectorButtons.forEach((button) => {
            button.addEventListener("click", () => {
                selectorButtons.forEach((candidate) => candidate.classList.remove("btn-active"));
                button.classList.add("btn-active");
                renderChart(button.dataset.mode);
            });
        });
    });
</script>
</body>
</html>
